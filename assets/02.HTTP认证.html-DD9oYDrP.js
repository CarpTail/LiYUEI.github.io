import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as a,b as t}from"./app-B18flpjG.js";const s="/assets/images/basic-auth.svg",n={},l=t('<h1 id="http认证" tabindex="-1"><a class="header-anchor" href="#http认证"><span>HTTP认证</span></a></h1><p>HTTP 提供一个用于权限控制和认证的通用框架。本页介绍了通用的 HTTP 认证框架， 并且展示了如何通过 HTTP 的“Basic”模式限制对你服务器的访问。</p><h2 id="通用的http认证框架" tabindex="-1"><a class="header-anchor" href="#通用的http认证框架"><span>通用的HTTP认证框架</span></a></h2><p>RFC 7235 定义了一个 HTTP 身份验证框架，服务器可以用来质询（challenge）客户端的请求， 客户端则可以提供身份验证凭据。</p><p>质询与响应的工作流程如下：</p><ol><li>服务器端向客户端返回 401（Unauthorized，未被授权的）响应状态码，并在 WWW-Authenticate 响应标头提供如何进行验证的信息，其中至少包含有一种质询方式。</li><li>之后，想要使用服务器对自己身份进行验证的客户端，可以通过包含凭据的 Authorization 请求标头进行验证。</li><li>通常，客户端会向用户显示密码提示，然后发送包含正确的 Authorization 标头的请求。</li></ol><figure><img src="'+s+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="认证代理" tabindex="-1"><a class="header-anchor" href="#认证代理"><span>认证代理</span></a></h3><p>与上述同样的询问质疑和响应原理适用于代理认证。由于资源认证和代理认证可以并存， 区别于独立的标头和响应状态码。对于代理，询问质疑的状态码是 407（必须提供代理证书）， 响应标头 Proxy-Authenticate 至少包含一个可用的质询，并且请求标头 Proxy-Authorization 用作向代理服务器提供凭据。</p><h3 id="禁止访问" tabindex="-1"><a class="header-anchor" href="#禁止访问"><span>禁止访问</span></a></h3><p>如果（代理）服务器收到无效的凭据，它应该响应 401 Unauthorized 或 407 Proxy Authentication Required， 用户可以发送新的请求或替换 Authorization 标头字段。</p><p>如果（代理）服务器接受的有效凭据不足以访问给定的资源，服务器将响应 403 Forbidden 状态码。 与 401 Unauthorized 或 407 Proxy Authentication Required 不同的是， 该用户无法进行身份验证并且浏览器不会提出新的尝试。</p><p>在所有情况下，服务器更可能返回 404 Not Found 状态码， 以向没有足够权限或者未正确身份验证的用户隐藏页面的存在。</p><h3 id="跨源图片认证" tabindex="-1"><a class="header-anchor" href="#跨源图片认证"><span>跨源图片认证</span></a></h3><p>一个被浏览器最近修复了的潜在的安全漏洞是跨站点图片的认证。从 Firefox 59 起， 浏览器在从不同源的加载图片资源到当前的文档时，将不会再触发 HTTP 认证对话框（Firefox bug 1423146）， 如果攻击者可以将任意图片嵌入到第三方页面中，禁止触发 HTTP 认证对话框可避免用户的身份凭据被窃取。</p><h3 id="http认证的字符编码" tabindex="-1"><a class="header-anchor" href="#http认证的字符编码"><span>HTTP认证的字符编码</span></a></h3><p>浏览器使用 utf-8 编码用户名和密码。</p><h3 id="www-authenticate-与-proxy-authenticate-标头" tabindex="-1"><a class="header-anchor" href="#www-authenticate-与-proxy-authenticate-标头"><span>WWW-Authenticate 与 Proxy-Authenticate 标头</span></a></h3><p>WWW-Authenticate 与 Proxy-Authenticate 响应标头指定了为获取资源访问权限而进行身份验证的方法。 它们需要明确要进行验证的方案，这样希望进行授权的客户端就知道该如何提供凭据。</p><p>这两个标头的语法形式如下：</p><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" data-title="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">WWW-Authenticate</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;type&gt; realm=&lt;realm&gt;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Proxy-Authenticate</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;type&gt; realm=&lt;realm&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，<code>&lt;type&gt;</code> 指的是验证的方案（“Basic”是最常见的验证方案，会在下面进行介绍）。 <code>realm</code> 用来描述进行保护的区域，或者指代保护的范围。它可以是类似于“Access to the staging site”的消息， 这样用户就可以知道他们正在试图访问哪一空间。</p><h3 id="authorization-与-proxy-authorization-标头" tabindex="-1"><a class="header-anchor" href="#authorization-与-proxy-authorization-标头"><span>Authorization 与 Proxy-Authorization 标头</span></a></h3><p>Authorization 与 Proxy-Authorization 请求标头包含有用来向（代理）服务器证明用户代理身份的凭据。 这里同样需要指明验证的 <code>&lt;type&gt;</code>，其后跟有凭据信息，该凭据信息可以被编码或者加密， 取决于采用的是哪种验证方案。</p><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" data-title="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Authorization</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;type&gt; &lt;credentials&gt;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Proxy-Authorization</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;type&gt; &lt;credentials&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="身份验证方案" tabindex="-1"><a class="header-anchor" href="#身份验证方案"><span>身份验证方案</span></a></h3><ul><li>Basic</li><li>Bearer</li><li>Digest</li><li>HOBA</li><li>Mutual</li><li>Negotiate / NTLM</li><li>VAPID</li><li>SCRAM</li><li>AWS4-HMAC-SHA256</li></ul><p>“Basic”身份验证方案安全性很差，但得到了广泛的支持且易于设置。下文将更详细地介绍它。</p><h2 id="basic验证方案" tabindex="-1"><a class="header-anchor" href="#basic验证方案"><span>Basic验证方案</span></a></h2><p>“Basic”HTTP 验证方案是在 RFC 7617 中规定的，在该方案中，使用用户的 ID/密码作为凭据信息， 并且使用 base64 算法进行编码。</p><h3 id="basic-验证方案的安全性" tabindex="-1"><a class="header-anchor" href="#basic-验证方案的安全性"><span>Basic 验证方案的安全性</span></a></h3><p>由于用户 ID 与密码是是以明文的形式在网络中进行传输的（尽管采用了 base64 编码， 但是 base64 算法是可逆的），所以基本验证方案并不安全。basic 验证方案应与 HTTPS/TLS 协议搭配使用。假如没有这些安全方面的增强，那么 basic 验证方案不应该被来用保护敏感或者 极具价值的信息。</p><h3 id="使用-apache-限制访问和-basic-身份验证" tabindex="-1"><a class="header-anchor" href="#使用-apache-限制访问和-basic-身份验证"><span>使用 Apache 限制访问和 basic 身份验证</span></a></h3><p>要对 Apache 服务器上的目录进行密码保护，你需要一个 .htaccess 和 a .htpasswd 文件。</p><p>该 .htaccess 文件格式通常看起来像这样：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>AuthType Basic</span></span>
<span class="line"><span>AuthName &quot;Access to the staging site&quot;</span></span>
<span class="line"><span>AuthUserFile /path/to/.htpasswd</span></span>
<span class="line"><span>Require valid-user</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该 .htaccess 文件引用一个 .htpasswd 文件，其中每行用冒号（:）分隔的用户名和密码。 你不能看到真实的密码因为它们是散列（在这个例子中是使用了 MD5）。你可以命名 .htpasswd 文件为你所喜欢的名字，但是应该保证这个文件不被其他人访问。 (Apache 通常配置阻止访问 .ht* 类的文件)。</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>aladdin:$apr1$ZjTqBB3f$IF9gdYAGlMrs2fuINjHsz.</span></span>
<span class="line"><span>user2:$apr1$O04r.y2H$/vEkesPhVInBByJUkXitA/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="nginx-访问限制和-basic-认证" tabindex="-1"><a class="header-anchor" href="#nginx-访问限制和-basic-认证"><span>nginx 访问限制和 basic 认证</span></a></h3><p>在 nginx 配置中，你需要指定一个要保护的 location 并且 auth_basic 指令提供密码保护区域的名称。</p><p>auth_basic_user_file 指令指定包含加密的用户凭据 .htpasswd 文件，就像上面的 apache 例子。</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>location /status {</span></span>
<span class="line"><span>    auth_basic           &quot;Access to the staging site&quot;;</span></span>
<span class="line"><span>    auth_basic_user_file /etc/apache2/.htpasswd;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用-url-中的身份凭据进行的访问" tabindex="-1"><a class="header-anchor" href="#使用-url-中的身份凭据进行的访问"><span>使用 URL 中的身份凭据进行的访问</span></a></h3><p>许多客户端同时支持避免弹出登录框，而是使用包含用户名和密码的经过编码的 URL，如下所示：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>https://username:password@www.example.com/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>这种 URL 已被弃用</code>。在 Chrome 中，URL 中的 username:password@ 部分甚至会因为安全原因而被移除。 Firefox 则会检查该站点是否真的需要身份验证，假如不是，则会弹出一个警告窗口： 你即将使用用户名 username 登录 www.example.com 站点，但是该站点不需要进行身份验证。 这可能是在试图进行欺诈。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication" target="_blank" rel="noopener noreferrer">MDN Web Docs 社区</a></p>`,48),h=[l];function r(p,c){return a(),i("div",null,h)}const u=e(n,[["render",r],["__file","02.HTTP认证.html.vue"]]),g=JSON.parse('{"path":"/05.Web%E6%8A%80%E6%9C%AF/HTTP/03.HTTP%E8%BF%9B%E9%98%B6/02.HTTP%E8%AE%A4%E8%AF%81.html","title":"HTTP认证","lang":"zh-CN","frontmatter":{"title":"HTTP认证","icon":"laptop-code","date":"2024-08-20T00:00:00.000Z","order":2,"category":["计算机网络"],"tag":["HTTP"],"description":"HTTP认证 HTTP 提供一个用于权限控制和认证的通用框架。本页介绍了通用的 HTTP 认证框架， 并且展示了如何通过 HTTP 的“Basic”模式限制对你服务器的访问。 通用的HTTP认证框架 RFC 7235 定义了一个 HTTP 身份验证框架，服务器可以用来质询（challenge）客户端的请求， 客户端则可以提供身份验证凭据。 质询与响应的...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/05.Web%E6%8A%80%E6%9C%AF/HTTP/03.HTTP%E8%BF%9B%E9%98%B6/02.HTTP%E8%AE%A4%E8%AF%81.html"}],["meta",{"property":"og:site_name","content":"Mr.Li"}],["meta",{"property":"og:title","content":"HTTP认证"}],["meta",{"property":"og:description","content":"HTTP认证 HTTP 提供一个用于权限控制和认证的通用框架。本页介绍了通用的 HTTP 认证框架， 并且展示了如何通过 HTTP 的“Basic”模式限制对你服务器的访问。 通用的HTTP认证框架 RFC 7235 定义了一个 HTTP 身份验证框架，服务器可以用来质询（challenge）客户端的请求， 客户端则可以提供身份验证凭据。 质询与响应的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/assets/images/basic-auth.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-27T07:21:04.000Z"}],["meta",{"property":"article:author","content":"Mr.Li"}],["meta",{"property":"article:tag","content":"HTTP"}],["meta",{"property":"article:published_time","content":"2024-08-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-27T07:21:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HTTP认证\\",\\"image\\":[\\"https://mister-hope.github.io/assets/images/basic-auth.svg\\"],\\"datePublished\\":\\"2024-08-20T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-27T07:21:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Li\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"通用的HTTP认证框架","slug":"通用的http认证框架","link":"#通用的http认证框架","children":[{"level":3,"title":"认证代理","slug":"认证代理","link":"#认证代理","children":[]},{"level":3,"title":"禁止访问","slug":"禁止访问","link":"#禁止访问","children":[]},{"level":3,"title":"跨源图片认证","slug":"跨源图片认证","link":"#跨源图片认证","children":[]},{"level":3,"title":"HTTP认证的字符编码","slug":"http认证的字符编码","link":"#http认证的字符编码","children":[]},{"level":3,"title":"WWW-Authenticate 与 Proxy-Authenticate 标头","slug":"www-authenticate-与-proxy-authenticate-标头","link":"#www-authenticate-与-proxy-authenticate-标头","children":[]},{"level":3,"title":"Authorization 与 Proxy-Authorization 标头","slug":"authorization-与-proxy-authorization-标头","link":"#authorization-与-proxy-authorization-标头","children":[]},{"level":3,"title":"身份验证方案","slug":"身份验证方案","link":"#身份验证方案","children":[]}]},{"level":2,"title":"Basic验证方案","slug":"basic验证方案","link":"#basic验证方案","children":[{"level":3,"title":"Basic 验证方案的安全性","slug":"basic-验证方案的安全性","link":"#basic-验证方案的安全性","children":[]},{"level":3,"title":"使用 Apache 限制访问和 basic 身份验证","slug":"使用-apache-限制访问和-basic-身份验证","link":"#使用-apache-限制访问和-basic-身份验证","children":[]},{"level":3,"title":"nginx 访问限制和 basic 认证","slug":"nginx-访问限制和-basic-认证","link":"#nginx-访问限制和-basic-认证","children":[]},{"level":3,"title":"使用 URL 中的身份凭据进行的访问","slug":"使用-url-中的身份凭据进行的访问","link":"#使用-url-中的身份凭据进行的访问","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1724743264000,"updatedTime":1724743264000,"contributors":[{"name":"lyw","email":"806555632@qq.com","commits":1}]},"readingTime":{"minutes":5.4,"words":1619},"filePathRelative":"05.Web技术/HTTP/03.HTTP进阶/02.HTTP认证.md","localizedDate":"2024年8月20日","excerpt":"\\n<p>HTTP 提供一个用于权限控制和认证的通用框架。本页介绍了通用的 HTTP 认证框架，\\n并且展示了如何通过 HTTP 的“Basic”模式限制对你服务器的访问。</p>\\n<h2>通用的HTTP认证框架</h2>\\n<p>RFC 7235 定义了一个 HTTP 身份验证框架，服务器可以用来质询（challenge）客户端的请求，\\n客户端则可以提供身份验证凭据。</p>\\n<p>质询与响应的工作流程如下：</p>\\n<ol>\\n<li>服务器端向客户端返回 401（Unauthorized，未被授权的）响应状态码，并在 WWW-Authenticate\\n响应标头提供如何进行验证的信息，其中至少包含有一种质询方式。</li>\\n<li>之后，想要使用服务器对自己身份进行验证的客户端，可以通过包含凭据的 Authorization 请求标头进行验证。</li>\\n<li>通常，客户端会向用户显示密码提示，然后发送包含正确的 Authorization 标头的请求。</li>\\n</ol>","autoDesc":true}');export{u as comp,g as data};
